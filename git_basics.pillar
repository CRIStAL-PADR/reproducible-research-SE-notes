!! Getting Started with Git

In this chapter we introduce the basics of Git and VCSs through guided examples.
We first start by setting up a repository in a remote server and then load it in our own machine.
We then show how we can inspect the state of our repository and save our files into it.
Once our changes are saved, we show how we can push our changes to our remote repository in a distant server.

This chapter will assume you have Git already installed in your machine, and that you're using a \*nix operating system.
For users of other systems such as Windows, an appendix at the end will give some details on different setups and installation procedures.
Moreover, you will see that we will approach Git with the ''command-line''.
Don't be affraid if you've never used it before, it is not as difficult as it may seem and you will get used to it.
There is always a first time!
Also, we promise you that everything you learn in here can be applied to, and will actually help you better understand, non command-line tools.

!!! Creating a Repository

A Git repository is a store of files and directories.
The big difference between a Git repository and a simple filesystem is that the changes we make are stored as events, like a timeline (Figure *@history_versions*).
Git not only stores such a timeline but also allows us to query it, undo some of its changes, and so on.

+A Repository as a timeline of changes>figures/history-versions.pdf|label=history_versions+

Before working with such a history/repository we need to set it up.
Fortunately, setting up a Git repository is much lightweight than setting up a database repository.
Though there are many different ways to create a Git repository, we will start with a simple solution to be up and running as fast as possible. We will study other ways to setup repositories in Chapter *@expert_git*.

Let's proceed to create a repository in an online hosting service such as GitHub or GitLab.
I'll give you some minutes to create an account and log into it.
Then you're ready to use the ''New Repository'' action, within the menu using the ==\+== symbol.
Figure *@new_repo_github* shows the kind of form GitHub provides to its users to create a new repository.

+Creating a New Repository in Github>figures/new-repository-github.png|label=new_repo_github+

Following the form/wizard will eventually get you a running repository on-line.
You will be most probably then redirected to your repository page.
Figure *@repository_page* shows how such a page looks in GitHub.

+A Repository Page for a project called ""test"" in GitHub>figures/GitHub_repository_page.png|label=repository_page+

We are almost set to work from the command line now.
However, we need to set-up our mind around a couple of extra concepts.
The repository we just created does not exist in our machine.
Actually, it is stored in some server maintained by github/gitlab.
To interact with this repository we will need a network connection.
We will call this repository, living in a remote server, a ""remote repository"".

!!! ==git clone==
@cloning

Git, constrastingly to other VCSs, is a distributed VCS.
This has a lot of consequences in the way we work, that we will study in detail in Chapter *@expert_git*.
For now, you will have to remember only one thing: instead of being connected all the time to our remote repository, we will copy the repository we just created in our machine.
Then we can work against our copy in the repository.
Eventually, we will synchronize the state between our local repository with the remote one.
This is what makes possible the disconnected or off-line workflow that people often praise in Git.

Making a local copy of a remote repository is such a common task that git has a dedicated command for it, the ==git clone [url]== command.
The ==git clone== command receives as argument the url of our repository, that we can get from our repository page.
You will see that your repository page will offer you different url options, the most used being SSH and HTTPS urls.
We will use in this chapter HTTPS urls because they have an easier setup, but for those readers that are curious, Section *@sshvshttps* compares SSH and HTTPS, and Section *@setupssh* shows how to setup your SSH environment.

To obtain the HTTPS url of your repository, go to your repository's page and look for it under the clone/HTTPS options.
As an example, Figure *@HTTPS_GitHub* illustrates how to get such url from a GitHub project page.

+Getting the HTTPS url of your repository from GitHub>figures/HTTPS_url_GitHub.png|width=90|label=HTTPS_GitHub+

Copy that url and use type your command as in:

[[[language=bash
$ git clone [url]
Cloning into '[your_project_name]'...
remote: Counting objects: 11082, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 11082 (delta 2), reused 6 (delta 2), pack-reused 11076
Receiving objects: 100% (11082/11082), 4.35 MiB | 1.22 MiB/s, done.
Resolving deltas: 100% (4063/4063), done.
Checking connectivity... done.
]]]

When the command finishes, Git is done creating a directory named as your repository (your_repo_name).
We will call this directory the ""working directory"" as it is where we will work and interact with our repository.
The working directory, with all the files and directories it contains, is managed git and linked to our repository.
Do not worry, there is nothing else you need to do to keep this link, Git will automatically track your changes for you.

You are now ready to go and start working on your project.

!!! Making Changes: How does Git manage my history?

Let's now dive in our working directory and start making changes to it.
I'll for example create a file called ==project.txt==, then open it with a text editor and add some lines to it.

[[[language=bash
$ cd your_project_name
$ touch project.txt
...
]]]

After some time working, I can use the ==ls== command to check the files in my directory.

[[[language=bash
$ ls
project.txt README.md
]]]

And then the ==cat== command to check their contents from the command line.

[[[
$ cat project.txt
# Done
 - created the repository
 - git clone
 - created this file
 
# To do
 - commit this file
 - push it to my remote repository
]]]

[[[language=bash
$ cat README.md
#My Project

This project is an example Git repository used to learn Git.
Check the project.txt file for information about pending tasks.
]]]

Basically, we have modified some files, but we have done no Git at all.
What does Git know about these files at this point?

!!!! Git does nothing without your permission

A new important thing to grasp about Git at this point is that it will do nothing until we explicitly ask it to do it.
In this sense, Git is not any kind of repository but a transactional repository.
All changes we do in our working directory are not stored by git automatically.
Instead, we need to explicitly store them using a ==commit== command, as we do with transactional database to store any data.

The transactional aspect means also that:
- while we do not commit, we can easily rollback our changes
- on the other side of the coin, until we commit we may lose our changes

We will see more of this ''explicitness'' applied in other cases throghover these chapters.
Sometimes it may seem that Git is just dumb, and that it cannot guess what we want to do when it is obvious.
However, the case is that Git has so many possibilities that not guessing is the healthier decision in most cases.
Specially when considering destructive operations that may make you lose hours of work.

!!!! ==git status==

We can then turn our question around: Does Git know something about these files?
Git indeed tracks our files to know what should be saved and what should not.
We can use this information to see what are actually the changes that happened while we were working.
The ==git status== command produces a list of the current changes.

[[[language=bash
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	project.txt

no changes added to commit (use "git add" and/or "git commit -a")
]]]

Reading the output of ==git status== we can see that it lists several things:
- ""Changes not staged for commit."" Lists the modified files that Git already knows.
- ""Untracked Files."" Lists the files that are in the working directory but were never added under the control of Git.

Also, ==git status== shows some hints about possible commands that we may use next such as ==git add== or ==git checkout==.

!!!! Git and directories

!!! ==git commit==

We would like now to save our changes in our Git repository.
This way, if anything happens, we can always recover our work up to this point.
Saving our work in the repository is called a ""commit"".
However, before committing our changes, we need to make Git ""track"" them.

To make it simple, you can see this whole tracking story as going to the supermarket.
If you want to buy something from the supermarket, you have take whatever you want first and put it in your basket.
Then, you go to the cashier, you pay and take your things home.
Now imagine that passing through the cashier to pay is equivalent to do a commit command.
This means that first you need to add stuff to your c!

Tracking changes for commit (''i.e.,'' adding stuff to your bag) is done through the ==git add [file]== command.
Let's proceed to track those changes and see what is the status of our repository afterwards.

[[[language=bash
$ git add README.md
$ git add project.txt
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   README.md
	new file:   project.txt
]]]

Now Git says that our two new files will be committed.
Let's now proceed to commit to save our changes in the repository.
We can do that by using the ==git commit -m \"[message]\"== command:

[[[language=bash
$ git commit -m "first version"
[master a93c016] first version
 2 files changed, 12 insertions(+), 1 deletion(-)
 create mode 100644 project.txt
]]]

If we see the status of our repository after the commit we will also see that it has changed.
There is nothing to commit:

[[[language=bash
$ git status
On branch master
nothing to commit, working directory clean
]]]

If we repeat the process and we change one of our existent files, we will see something interesting:

[[[
$ cat project.txt
# Done
 - created the repository
 - git clone
 - created this file
 - commit this file
 
# To do
 - push it to my remote repository
]]]

[[[language=bash
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   project.txt

no changes added to commit (use "git add" and/or "git commit -a")
]]]

Indeed, changing again the file requires that we do a ==git add [file]== and ==git commit== again on the same file, even if Git already knew about it.
This is because Git will ask us to explicitly track ""every change"" we do.
So we will need to repeat the same operation of before.

[[[language=bash
$ git add project.txt
$ git commit -m "Commit is not in ToDo anymore"
[master e14a09f] Commit is not in ToDo anymore
 1 file changed, 1 insertion(+), 1 deletion(-)
]]]

!!! Synchronizing with your Remote Repository

So far we have worked only on the local repository residing in our machine.
This means that mostly all of Git features are available without requiring an internet connection, making it suitable for working off-line (think on working on the train or with a constrained connection!). However, working off-line is a two-edged weapon: all your changes are captive in your machine.
While your changes are in your machine, nobody else can contribute or collaborate to them.
Moreover, losing your machine would mean losing all your changes too.
Keeping your changes safe means to synchronize them from time to time with your remote repository.

!!!! ==git pull==
@pulling_basic

Before being able to share our commits in some external server, we need before to update our repository to avoid them being de-synchronized.
While you can always try to share your commits by directly pushing (see Section *@pushing*), you will see with experience that Git favors pulling before pushing.
This is, among others, because in your local repository you can do whatever manipulation you want to solve mistakes and merge conflicts, while you cannot do the same in your remote repository.

For our example, pulling does not seem really necessary because you are the only person modifying your repository.
But let's imagine that you have done a modification in this same repository from another machine.
In that case, you would like to update your existing repository with the changes doing from this other machine.

Updating our repository is done through the ==git pull== command.
Pulling will update our database and then update our files.

[[[language=bash
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0
Unpacking objects: 100% (2/2), done.
From https://github.com/guillep/test
   1656797..a2dbd8b  master     -> origin/master
Updating 1656797..a2dbd8b
Fast-forward
 newfile | 0
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 newfile
]]]

Three different scenarios can actually happen from a pull operation, which will be studied in detail in Section *@merging*:
- ""Fast-forward"": the updates were applied without needing a merge.
- ""Automatic Merge"": the updates were applied without conflicts. Git had to do a merge commit and will ask you for a commit message.
- ""Merge Conflict"": the updates could not applied. You need to manually resolve conflicts between your changes and the incoming changes.

Fast-forward and automatic merge are the simplest ones to manage since they require almost no manual interaction other than introducing a message.

!!!! ==git push==
@pushing

The final step in our Git journey is to share our changes to the world.
Such sharing is done by ""push""ing commits to a remote repository, as shown in Figure *@push_in_workflow*.
To push, you need to use the git command ==git push [remote] [remote_branch]==.
This command will send the commits pointed from your your current branch to the remote [remote] in the branch [remote_branch].

[[[language=bash
$ git push origin temp
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:[your_username]/[your_repo_name].git
   b6dcc3f..f269295  master -> temp
]]]

+Push is an operation that sends commits from your local repository to a remote repository.>figures/push_in_workflow.pdf|width=90|label=push_in_workflow+

To avoid specifying the remote and destination branch on every push (which may be a bit verbose), you can avoid those parameters and rely on Git default values.
By default the ==git push== operation will try to push to the ""branch's upstream"".
A branch's upstream is the per-branch configuration saying to which remote/branch pair it should push by default.
When we clone a repository, the default branch comes with an already configured upstream.
We can interrogate Git for the branch's upstreams with the super verbose flag in the branch command, ''i.e.'', ==git branch \-vv==, where we can see for example that our ""master"" branch's upstream is ""origin/master"", while our ""development"" branch has no upstream.

[[[language=bash
$ git branch -vv   # doubly verbose!
  development   1656797 This commit adds a new feature
  master        f269295 [origin/master] First commit
]]]

On the other side, when a branch has no upstream, a push operation will by default fail with a Git error.
Git will ask us to set an upstream, or otherwise specify a pair remote/branch for each push.

[[[language=bash
$ git push
fatal: The current branch test has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin test

$ git push --set-upstream origin test
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 271 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:[your_username]/[your_repo_name].git
   b6dcc3f..f269295  master -> test

]]]

Finally, another thing may happen while pushing: Git may reject our changes.

[[[language=bash
$ git push
To git@github.com:guillep/test.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'git@github.com:[your_username]/[your_repo_name].git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
]]] 

As the error message says, the remote has changes that we do not have locally, so we need to update our repository first.
This can be solved with a pull (Section *@pulling*) and a merge (*@merging*)


!!! Exercises (Guille 100%)

# ""Exercise 1"". Create an account in your preferred git repository hosting service, create there a repository and clone it. Then, check its history from the command line. How many commits are there in the repository? __Tip: there is a difference if you checked the "create README.md file" checkbox while creating a repository__.

# ""Exercise 2"". Create a file, a file inside a directory and an empty directory. Commit them (remember, ==git add==, ==git commit==). What can you see there? How does Git manage directories?

# ""Exercise 3"". If you're on a unix system (linux/osx), try changing your file's permissions and check ==git status==. How does git treat file permissions? Commit your changes and check the log. What can you observe?

# ""Exercise 4"". Push now your changes to your remote repository. Then, clone your repository again in another directory. Tip: try checking the help of the clone command ==git clone -h==. Did git save all your files, directories and even permissions?

# ""Exercise 5"". Go back to your first repository, add a new file, commit it and push it. Then go back to the second repository and pull. Inspect the history in both repositories: Is it the same?

# ""Exercise 6"". Check your online repository on your hosting service. Can you see the same state as in your local repositories? Go over the different tools offered by the hosting, they usually give some idea of the activity of the project, try to understand what they are for.